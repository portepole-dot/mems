<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ионогелевый нейрокомпьютер In-Materio V2.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        :root {
            --bg-abyssal: #01060e;
            --bg-panel: rgba(2, 12, 24, 0.85);
            --toxic-green: #39ff14;
            --amber-ion: #ffb300;
            --amber-glow: rgba(255, 179, 0, 0.6);
            --cyan-readout: #00e5ff;
            --panel-border: rgba(57, 255, 20, 0.3);
            --alert-red: #ff003c;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-abyssal);
            color: var(--toxic-green);
            font-family: 'Share Tech Mono', monospace;
            overflow: hidden;
            user-select: none;
        }

        /* Fullscreen p5.js Canvas */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            width: 100%;
            height: 100%;
            transition: transform 0.1s; /* For shake effect */
        }

        /* Frost Vignette Overlay */
        #frost-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 40%, rgba(200, 240, 255, 0.15) 80%, rgba(150, 220, 255, 0.4) 100%);
            box-shadow: inset 0 0 100px rgba(100, 200, 255, 0.2);
            opacity: 0;
            transition: opacity 2s ease-in-out;
            backdrop-filter: blur(0px); /* Will animate in JS if needed */
        }

        /* Shake Animation */
        .shake {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-2px, 2px, 0); }
            20%, 80% { transform: translate3d(4px, -3px, 0); }
            30%, 50%, 70% { transform: translate3d(-6px, 4px, 0); }
            40%, 60% { transform: translate3d(6px, -2px, 0); }
        }

        /* UI Grid Layout */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
            display: grid;
            grid-template-columns: 45% 55%;
            grid-template-rows: 60px 1fr 280px;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px;
        }

        /* Panels */
        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--panel-border);
            box-shadow: 0 0 15px rgba(0, 20, 40, 0.8);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            position: relative;
            backdrop-filter: blur(4px);
        }

        .panel-title {
            background: var(--toxic-green);
            color: #000;
            padding: 4px 10px;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: inline-block;
            align-self: flex-start;
            box-shadow: 0 0 8px var(--toxic-green);
        }

        /* Header */
        header {
            grid-column: 1 / 3;
            grid-row: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--toxic-green);
            padding-bottom: 10px;
            text-shadow: 0 0 5px var(--toxic-green);
        }

        header h1 {
            margin: 0;
            font-size: 22px;
            letter-spacing: 1.5px;
        }

        /* Specific Panels */
        #panel-1 {
            grid-column: 1;
            grid-row: 2 / 4;
            background: transparent;
            border: none;
            box-shadow: none;
            pointer-events: none;
            backdrop-filter: none; /* Убираем размытие канваса под прозрачной панелью */
        }

        .floating-label {
            position: absolute;
            font-size: 12px;
            background: rgba(0,0,0,0.6);
            padding: 4px;
            border: 1px solid var(--toxic-green);
        }

        #panel-2 {
            grid-column: 2;
            grid-row: 2;
            background: transparent;
            border: none;
            box-shadow: none;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            backdrop-filter: none; /* Убираем размытие канваса под прозрачной панелью */
        }

        .memory-status {
            text-align: right;
            padding: 10px 20px;
            font-size: 14px;
            color: var(--cyan-readout);
            text-shadow: 0 0 8px var(--cyan-readout);
            background: rgba(0, 10, 20, 0.7);
            border-left: 2px solid var(--cyan-readout);
            align-self: flex-end;
            margin-top: 10px;
        }

        /* Controls Panel (Panel 3) */
        #panel-3 {
            grid-column: 2;
            grid-row: 3;
            display: flex;
            flex-direction: row;
            gap: 20px;
            padding: 15px;
            background: rgba(2, 10, 15, 0.9);
        }

        .controls-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            justify-content: center;
        }

        .controls-right {
            flex: 1.2;
            display: flex;
            flex-direction: column;
        }

        /* Buttons */
        .btn {
            background: rgba(0, 20, 30, 0.6);
            color: var(--toxic-green);
            border: 1px solid var(--toxic-green);
            padding: 12px 8px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            text-align: left;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: var(--toxic-green);
            color: #000;
            box-shadow: 0 0 15px var(--toxic-green);
        }
        
        .btn::before {
            content: '>';
            margin-right: 8px;
            opacity: 0.5;
        }

        .btn:hover::before {
            opacity: 1;
        }

        .btn-frost {
            border-color: #00d4ff;
            color: #00d4ff;
        }
        .btn-frost:hover {
            background: #00d4ff;
            box-shadow: 0 0 15px #00d4ff;
            color: #000;
        }

        .btn-pressure {
            border-color: var(--alert-red);
            color: var(--alert-red);
        }
        .btn-pressure:hover {
            background: var(--alert-red);
            box-shadow: 0 0 15px var(--alert-red);
            color: #000;
        }

        /* Terminal Display */
        #terminal {
            flex: 1;
            background: rgba(0, 5, 10, 0.9);
            border: 1px solid rgba(57, 255, 20, 0.2);
            padding: 12px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.5;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .log-entry { margin: 0; font-family: 'Share Tech Mono', monospace; }
        .log-info { color: var(--toxic-green); }
        .log-warn { color: var(--amber-ion); }
        .log-crit { color: var(--alert-red); font-weight: bold; text-shadow: 0 0 4px var(--alert-red); }
        .log-sys { color: var(--cyan-readout); }

        /* Scrollbar */
        #terminal::-webkit-scrollbar { width: 4px; }
        #terminal::-webkit-scrollbar-track { background: transparent; }
        #terminal::-webkit-scrollbar-thumb { background: var(--toxic-green); }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="frost-overlay"></div>

    <div id="ui-layer">
        <header>
            <h1>ИОНОГЕЛЕВЫЙ НЕЙРОКОМПЬЮТЕР IN-MATERIO V2.0</h1>
            <div style="display: flex; gap: 15px; font-size: 14px;">
                <span style="color: var(--cyan-readout)">СОСТОЯНИЕ: ВЯЗКОЕ</span>
                <span style="color: var(--amber-ion)">ПАМЯТЬ: ЭНЕРГОНЕЗАВИСИМАЯ</span>
            </div>
        </header>

        <div id="panel-1" class="panel">
            <div class="panel-title">ПАНЕЛЬ 1: КАМЕРА ИОНОГЕЛЯ И ИНТЕРКАЛЯЦИЯ</div>
            <div class="floating-label" style="top: 60px; left: 20px; color: var(--toxic-green);">
                [>] МАССИВ ПЬЕЗО-ВОРСИНОК (АКУСТИЧЕСКИЙ ПРИЕМ)
            </div>
            <div class="floating-label" style="bottom: 120px; left: 20px; color: var(--amber-ion); border-color: var(--amber-ion);">
                [v] ЭЛЕКТРОХИМИЧЕСКАЯ ИНТЕРКАЛЯЦИЯ
            </div>
        </div>

        <div id="panel-2" class="panel">
            <div>
                <div class="panel-title">ПАНЕЛЬ 2: ЭНЕРГОНЕЗАВИСИМОЕ СЧИТЫВАНИЕ IN-MATERIO</div>
            </div>
            <div class="memory-status">
                ПАМЯТЬ ВШИТА В АТОМНУЮ РЕШЕТКУ<br>
                <span style="font-size: 11px; color: rgba(0,229,255,0.7);">(ЭНЕРГОНЕЗАВИСИМАЯ ИНТЕРКАЛЯЦИЯ)</span>
            </div>
        </div>

        <div id="panel-3" class="panel">
            <div class="panel-title" style="position: absolute; top: -14px; left: -1px; z-index: 10;">ПАНЕЛЬ 3: ТЕСТЫ В ЭКСТРЕМАЛЬНОЙ СРЕДЕ (RED TEAM)</div>
            
            <div class="controls-left">
                <button class="btn btn-pressure" id="btn-pressure">ГИДРОСТАТИЧЕСКОЕ ДАВЛЕНИЕ БЕЗДНЫ (500 АТМ)</button>
                <button class="btn btn-frost" id="btn-frost">АРКТИЧЕСКАЯ ЗАМОРОЗКА (-80°C)</button>
                <button class="btn" id="btn-diffusion" style="color: var(--amber-ion); border-color: var(--amber-ion);">ПРОВЕРКА ДИФФУЗИИ ПАМЯТИ</button>
            </div>

            <div class="controls-right">
                <div id="terminal">
                    <div class="log-entry log-sys">[СИС] ИНИЦИАЛИЗАЦИЯ ИОНОГЕЛЕВОЙ МАТРИЦЫ V2.0...</div>
                    <div class="log-entry log-info">[ИНФО] МАССИВ ВОРСИНОК РЕАГИРУЕТ.</div>
                    <div class="log-entry log-sys">[СИС] СЛОТЫ РЕШЕТКИ ОЖИДАЮТ ИНТЕРКАЛЯЦИИ.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- UI Interaction Logic ---
        const terminal = document.getElementById('terminal');
        const canvasContainer = document.getElementById('canvas-container');
        const frostOverlay = document.getElementById('frost-overlay');
        
        function logMsg(msg, level="info") {
            const div = document.createElement('div');
            div.className = `log-entry log-${level}`;
            const time = new Date().toISOString().substring(11, 23);
            div.textContent = `[${time}] ${msg}`;
            terminal.appendChild(div);
            terminal.scrollTop = terminal.scrollHeight;
            if (terminal.childElementCount > 30) {
                terminal.removeChild(terminal.firstChild);
            }
        }

        document.getElementById('btn-pressure').addEventListener('click', () => {
            // Visual Shake
            canvasContainer.classList.remove('shake');
            void canvasContainer.offsetWidth; // trigger reflow
            canvasContainer.classList.add('shake');
            
            // P5 physics shockwave
            if(window.p5System) window.p5System.triggerShockwave();

            logMsg("ПРИМЕНЕНИЕ ГИДРОСТАТИЧЕСКОГО ДАВЛЕНИЯ 500 АТМ...", "crit");
            setTimeout(() => {
                logMsg("НЕСЖИМАЕМЫЙ ИОНОГЕЛЬ. ВЫДЕРЖАНО 500 АТМ. ВАКУУМНЫЕ МЭМС ОТ IARPA БЫЛИ БЫ РАЗДАВЛЕНЫ.", "sys");
            }, 600);
        });

        document.getElementById('btn-frost').addEventListener('click', () => {
            // Apply frost overlay
            frostOverlay.style.opacity = "1";
            frostOverlay.style.backdropFilter = "blur(2px)";
            
            // Change physics state in p5
            if(window.p5System) window.p5System.setViscosity(0.95);

            logMsg("СНИЖЕНИЕ ТЕМПЕРАТУРЫ СРЕДЫ ДО -80°C...", "sys");
            setTimeout(() => {
                logMsg("АКТИВИРОВАН АНТИФРИЗ ИОНОГЕЛЯ. СОСТОЯНИЕ: ВЯЗКОЕ. СИСТЕМА В НОРМЕ.", "info");
            }, 800);
            
            // Auto-thaw after 10 seconds to keep simulation visually interesting
            setTimeout(() => {
                frostOverlay.style.opacity = "0";
                frostOverlay.style.backdropFilter = "blur(0px)";
                if(window.p5System) window.p5System.setViscosity(0.5); // Normal
                logMsg("ТЕМПЕРАТУРА НОРМАЛИЗУЕТСЯ.", "sys");
            }, 10000);
        });

        document.getElementById('btn-diffusion').addEventListener('click', () => {
            logMsg("АНАЛИЗ СОСТОЯНИЯ УДЕРЖАНИЯ РЕШЕТКИ...", "warn");
            
            // Trigger a visual sweep in p5
            if(window.p5System) window.p5System.triggerDiffusionCheck();

            setTimeout(() => {
                logMsg("ИНТЕРКАЛИРОВАННЫЕ ИОНЫ ЗАФИКСИРОВАНЫ В РЕШЕТКЕ. НУЛЕВАЯ БРОУНОВСКАЯ ДИФФУЗИЯ. ПАМЯТЬ СОХРАНЯЕТСЯ БОЛЕЕ 10 ЛЕТ.", "sys");
            }, 1000);
        });


        // --- P5.JS Simulation Backend ---
        const sketch = (p) => {
            
            // Colors
            const C_ABYSS = p.color(1, 6, 14);
            const C_GEL = p.color(5, 20, 35, 150);
            const C_TOXIC = p.color(57, 255, 20);
            const C_AMBER = p.color(255, 179, 0);
            const C_CYAN = p.color(0, 229, 255);
            
            // Simulation Parameters
            let viscosity = 0.5; // Controls falling speed of ions
            let timeStep = 0;
            let shockwave = 0;
            
            // Layout zones
            let chamberZone, scopeZone;
            
            // Entities
            let ciliaArray = [];
            let freeIons = [];
            let latticeGrid = [];
            
            // Lattice definitions
            const HEX_R = 12;
            let latticeRows = 5;
            let latticeCols = 0;
            let latticeStartX = 0;
            let latticeStartY = 0;

            // Acoustic Wave
            let waveX = 0;
            let waveSpeed = 2;

            // Oscilloscope Readout
            let scopeHistory = [];
            const MAX_SCOPE = 200;
            let readoutScanlineX = 0;
            let isCheckingDiffusion = false;
            let diffusionCheckAlpha = 0;

            p.setup = () => {
                let canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('canvas-container');
                p.frameRate(60);
                
                initZones();
                initChamber();

                window.p5System = {
                    setViscosity: (v) => { viscosity = v; },
                    triggerShockwave: () => { shockwave = 20; },
                    triggerDiffusionCheck: () => { 
                        isCheckingDiffusion = true; 
                        diffusionCheckAlpha = 255;
                        setTimeout(() => { isCheckingDiffusion = false; }, 2000);
                    }
                };
            };

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                initZones();
                initChamber(); 
            };

            function initZones() {
                chamberZone = {
                    x: 20,
                    y: 100,
                    w: p.width * 0.45 - 40,
                    h: p.height - 120
                };
                scopeZone = {
                    x: p.width * 0.45 + 20,
                    y: 100,
                    w: p.width * 0.55 - 40,
                    h: p.height * 0.4
                };
            }

            function initChamber() {
                // Initialize Cilia Array (top of the chamber)
                ciliaArray = [];
                let numCilia = Math.floor(chamberZone.w / 15);
                let ciliaSpacing = chamberZone.w / numCilia;
                for(let i=0; i < numCilia; i++) {
                    ciliaArray.push({
                        x: chamberZone.x + i * ciliaSpacing + 10,
                        y: chamberZone.y + 40,
                        length: p.random(60, 100),
                        basePhase: p.random(p.TWO_PI),
                        bendAmount: 0
                    });
                }

                // Initialize Lattice Grid (bottom of the chamber)
                latticeGrid = [];
                latticeCols = Math.floor(chamberZone.w / (HEX_R * 1.8));
                let gridW = latticeCols * (HEX_R * 1.732);
                latticeStartX = chamberZone.x + (chamberZone.w - gridW)/2 + 10;
                latticeStartY = chamberZone.y + chamberZone.h - (latticeRows * HEX_R * 1.6) - 20;

                for(let r=0; r < latticeRows; r++) {
                    let rowArr = [];
                    // Staggered columns
                    let colsInRow = (r % 2 === 0) ? latticeCols : latticeCols - 1;
                    let xOffset = (r % 2 === 0) ? 0 : (HEX_R * 0.866);
                    
                    for(let c=0; c < colsInRow; c++) {
                        rowArr.push({
                            x: latticeStartX + c * (HEX_R * 1.732) + xOffset,
                            y: latticeStartY + r * (HEX_R * 1.5),
                            isFilled: false,
                            pulseTime: 0
                        });
                    }
                    latticeGrid.push(rowArr);
                }

                freeIons = [];
                waveX = chamberZone.x;
                readoutScanlineX = latticeStartX;
            }

            p.draw = () => {
                p.clear();
                timeStep += 0.05;
                if (shockwave > 0) shockwave -= 1;

                drawIonogelBackground();
                updateAndDrawAcousticWave();
                updateAndDrawCilia();
                updateAndDrawIons();
                drawLattice();
                drawOscilloscope();
                
                if (isCheckingDiffusion) {
                    drawDiffusionCheckOverlay();
                }
            };

            function drawIonogelBackground() {
                // Draw a thick gel-like background in the chamber zone
                p.noStroke();
                for(let i=0; i<10; i++) {
                    p.fill(5, 15 + i*2, 25 + i*3, 20);
                    p.rect(chamberZone.x, chamberZone.y + i*(chamberZone.h/10), chamberZone.w, chamberZone.h/10);
                }
                
                // Border
                p.stroke(0, 50, 100, 100);
                p.strokeWeight(2);
                p.noFill();
                p.rect(chamberZone.x, chamberZone.y, chamberZone.w, chamberZone.h);
            }

            function updateAndDrawAcousticWave() {
                waveX += waveSpeed * (1.5 - viscosity); // slower if viscous
                if (waveX > chamberZone.x + chamberZone.w) {
                    waveX = chamberZone.x; // Loop wave
                }

                // Draw wave representation (сделано ярче и толще)
                p.stroke(0, 255, 150, 60);
                p.strokeWeight(15);
                p.line(waveX, chamberZone.y, waveX, chamberZone.y + chamberZone.h);
                p.strokeWeight(4);
                p.stroke(0, 255, 200, 200);
                p.line(waveX, chamberZone.y, waveX, chamberZone.y + chamberZone.h);
            }

            function updateAndDrawCilia() {
                p.noFill();
                for (let c of ciliaArray) {
                    // Calculate distance to wave
                    let d = p.abs(c.x - waveX);
                    let waveInfluence = p.max(0, 1 - d / 50);
                    
                    // Add environmental shockwave
                    let shock = p.random(-shockwave, shockwave) * 0.1;

                    // Calculate bend
                    let ambientBend = p.sin(timeStep + c.basePhase) * 0.2;
                    c.bendAmount = p.lerp(c.bendAmount, (waveInfluence * 1.5) + ambientBend + shock, 0.2);

                    // Draw organic curve (cilia) (сделано толще)
                    p.stroke(C_TOXIC);
                    p.strokeWeight(4);
                    p.beginShape();
                    p.vertex(c.x, c.y);
                    
                    let cx1 = c.x;
                    let cy1 = c.y + c.length * 0.3;
                    
                    let cx2 = c.x + c.bendAmount * 40;
                    let cy2 = c.y + c.length * 0.7;
                    
                    let endX = c.x + c.bendAmount * 60;
                    let endY = c.y + c.length;
                    
                    p.bezierVertex(cx1, cy1, cx2, cy2, endX, endY);
                    p.endShape();

                    // Ion shedding logic (Electrochemical release)
                    // High bend + probability = shed ion
                    if (waveInfluence > 0.8 && p.random(1) < 0.05) {
                        spawnIon(endX, endY);
                    }
                }
            }

            function spawnIon(x, y) {
                freeIons.push({
                    x: x,
                    y: y,
                    vx: p.random(-1, 1),
                    vy: p.random(0.5, 1.5),
                    state: 'falling', // 'falling', 'snapping'
                    targetSlot: null
                });
            }

            function updateAndDrawIons() {
                // Update and draw free ions
                for (let i = freeIons.length - 1; i >= 0; i--) {
                    let ion = freeIons[i];

                    if (ion.state === 'falling') {
                        // Incompressible fluid physics (Brownian motion + gravity + viscosity)
                        // Higher viscosity = slower, more lateral drift
                        let drift = p.random(-1, 1) * viscosity * 2;
                        
                        ion.x += ion.vx + drift + p.random(-shockwave, shockwave)*0.2;
                        ion.y += ion.vy * (1.0 - viscosity + 0.2); // Fall speed modified by viscosity
                        
                        // Keep in bounds
                        if (ion.x < chamberZone.x) ion.x = chamberZone.x;
                        if (ion.x > chamberZone.x + chamberZone.w) ion.x = chamberZone.x + chamberZone.w;

                        // Check if deep enough to start looking for a lattice slot
                        if (ion.y > latticeStartY - 40) {
                            findNearestEmptySlot(ion);
                        }

                        // Remove if it falls out of bounds without snapping
                        if (ion.y > chamberZone.y + chamberZone.h) {
                            freeIons.splice(i, 1);
                            continue;
                        }

                    } else if (ion.state === 'snapping') {
                        // Vigorously lerp to the slot
                        ion.x = p.lerp(ion.x, ion.targetSlot.x, 0.3);
                        ion.y = p.lerp(ion.y, ion.targetSlot.y, 0.3);

                        let d = p.dist(ion.x, ion.y, ion.targetSlot.x, ion.targetSlot.y);
                        if (d < 1.0) {
                            // INTERCALATION COMPLETE
                            ion.targetSlot.isFilled = true;
                            ion.targetSlot.pulseTime = 1.0; // Flash
                            freeIons.splice(i, 1); // Remove from active tracking
                            continue;
                        }
                    }

                    // Draw free ion
                    p.noStroke();
                    p.fill(255, 179, 0, 200);
                    p.circle(ion.x, ion.y, 6);
                    // Glow
                    p.fill(255, 179, 0, 50);
                    p.circle(ion.x, ion.y, 14);
                }
            }

            function findNearestEmptySlot(ion) {
                let closestDist = 50; // Capture radius
                let closestSlot = null;

                for (let r = 0; r < latticeRows; r++) {
                    for (let c = 0; c < latticeGrid[r].length; c++) {
                        let slot = latticeGrid[r][c];
                        if (!slot.isFilled && !slot.isTargeted) {
                            let d = p.dist(ion.x, ion.y, slot.x, slot.y);
                            if (d < closestDist) {
                                closestDist = d;
                                closestSlot = slot;
                            }
                        }
                    }
                }

                if (closestSlot) {
                    ion.state = 'snapping';
                    ion.targetSlot = closestSlot;
                    closestSlot.isTargeted = true; // Prevent other ions from stealing it
                }
            }

            function drawHex(x, y, r) {
                p.beginShape();
                for (let a = p.PI/6; a < p.TWO_PI; a += p.PI/3) { // rotate for pointy top
                    p.vertex(x + p.cos(a) * r, y + p.sin(a) * r);
                }
                p.endShape(p.CLOSE);
            }

            function drawLattice() {
                p.strokeWeight(1);
                
                for (let r = 0; r < latticeRows; r++) {
                    for (let c = 0; c < latticeGrid[r].length; c++) {
                        let slot = latticeGrid[r][c];
                        
                        if (slot.isFilled) {
                            // Intercalated Memory State
                            
                            // Base hex
                            p.stroke(C_AMBER);
                            p.fill(100, 70, 0, 150);
                            drawHex(slot.x, slot.y, HEX_R - 1);
                            
                            // Locked Ion core
                            p.noStroke();
                            p.fill(255, 200, 50, 255);
                            p.circle(slot.x, slot.y, 5);
                            
                            // Snapping pulse effect
                            if (slot.pulseTime > 0) {
                                p.noFill();
                                p.stroke(255, 179, 0, slot.pulseTime * 255);
                                p.strokeWeight(2);
                                drawHex(slot.x, slot.y, HEX_R + (1-slot.pulseTime)*10);
                                slot.pulseTime -= 0.05;
                            }

                            // Diffusion check ping
                            if (isCheckingDiffusion) {
                                p.fill(C_CYAN.levels[0], C_CYAN.levels[1], C_CYAN.levels[2], p.random(100, 200));
                                p.circle(slot.x, slot.y, 8);
                            }

                        } else {
                            // Empty Crystalline State (сделано ярче)
                            p.stroke(0, 150, 200, 150);
                            p.noFill();
                            drawHex(slot.x, slot.y, HEX_R - 1);
                        }
                    }
                }
            }

            function drawDiffusionCheckOverlay() {
                // Overlay text/fx over lattice during check
                p.fill(0, 229, 255, diffusionCheckAlpha);
                p.noStroke();
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(16);
                p.text("ОБНАРУЖЕН НУЛЕВОЙ БРОУНОВСКИЙ ДРЕЙФ", chamberZone.x + chamberZone.w/2, latticeStartY - 20);
                
                diffusionCheckAlpha = p.max(0, diffusionCheckAlpha - 5);
            }

            function drawOscilloscope() {
                // Background grid for scope (сделано ярче)
                p.stroke(0, 80, 100, 200);
                p.strokeWeight(1);
                for (let i = 0; i < 5; i++) {
                    let y = scopeZone.y + i * (scopeZone.h / 4);
                    p.line(scopeZone.x, y, scopeZone.x + scopeZone.w, y);
                }

                // Scanline logic: swept left to right reading the lattice columns
                readoutScanlineX += 2;
                if (readoutScanlineX > latticeStartX + latticeCols * (HEX_R * 1.732)) {
                    readoutScanlineX = latticeStartX;
                }

                // Determine which column we are currently reading
                let currentColIndex = Math.floor((readoutScanlineX - latticeStartX) / (HEX_R * 1.732));
                let filledCount = 0;
                let colTargetWave = 0;
                
                if (currentColIndex >= 0 && currentColIndex < latticeCols) {
                    // Count filled slots in this vertical column
                    for (let r = 0; r < latticeRows; r++) {
                        if (currentColIndex < latticeGrid[r].length && latticeGrid[r][currentColIndex].isFilled) {
                            filledCount++;
                        }
                    }
                    
                    // The "Target Wave" is a standing sine wave that the system is trying to memorize
                    let normalizedX = currentColIndex / latticeCols;
                    colTargetWave = p.sin(normalizedX * p.TWO_PI * 2) * 0.5 + 0.5; // 0 to 1
                }

                // Record to history
                // Signal amplitude based on percentage of column filled
                let memoryAmplitude = filledCount / latticeRows; 
                
                scopeHistory.push({
                    target: colTargetWave,
                    readout: memoryAmplitude
                });

                if (scopeHistory.length > MAX_SCOPE) {
                    scopeHistory.shift();
                }

                // Draw Target Waveform (Faint Blue/Green) (сделано толще и ярче)
                p.noFill();
                p.stroke(0, 200, 150, 150);
                p.strokeWeight(3);
                p.beginShape();
                for (let i = 0; i < scopeHistory.length; i++) {
                    let x = scopeZone.x + p.map(i, 0, MAX_SCOPE, 0, scopeZone.w);
                    let y = scopeZone.y + scopeZone.h - scopeHistory[i].target * scopeZone.h * 0.8 - 10;
                    p.vertex(x, y);
                }
                p.endShape();

                // Draw In-Materio Readout Waveform (Cyan) (сделано толще)
                p.stroke(C_CYAN);
                p.strokeWeight(3);
                p.beginShape();
                for (let i = 0; i < scopeHistory.length; i++) {
                    let x = scopeZone.x + p.map(i, 0, MAX_SCOPE, 0, scopeZone.w);
                    let y = scopeZone.y + scopeZone.h - scopeHistory[i].readout * scopeZone.h * 0.8 - 10;
                    p.vertex(x, y);
                }
                p.endShape();

                // Draw scope scan head
                if (scopeHistory.length > 0) {
                    let lastX = scopeZone.x + scopeZone.w;
                    let lastY = scopeZone.y + scopeZone.h - scopeHistory[scopeHistory.length-1].readout * scopeZone.h * 0.8 - 10;
                    p.fill(C_CYAN);
                    p.noStroke();
                    p.circle(lastX, lastY, 6);
                    
                    // Vertical sweep line
                    p.stroke(C_CYAN.levels[0], C_CYAN.levels[1], C_CYAN.levels[2], 50);
                    p.strokeWeight(1);
                    p.line(lastX, scopeZone.y, lastX, scopeZone.y + scopeZone.h);
                }

                // Show physical scanline on lattice corresponding to scope readout
                p.stroke(0, 229, 255, 100);
                p.strokeWeight(2);
                p.line(readoutScanlineX, latticeStartY - 20, readoutScanlineX, latticeStartY + latticeRows*HEX_R*1.5 + 10);
                p.fill(0, 229, 255, 150);
                p.noStroke();
                p.triangle(readoutScanlineX-5, latticeStartY - 25, readoutScanlineX+5, latticeStartY - 25, readoutScanlineX, latticeStartY - 15);
            }
        };

        // Initialize p5
        new p5(sketch);

    </script>
</body>
</html>
