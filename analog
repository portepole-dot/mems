<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analog Stochastic Swarm & Memristor Crossbar</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        :root {
            --bg-color: #030a05;
            --neon-green: #39ff14;
            --amber: #ffbf00;
            --cyan: #00ffff;
            --magenta: #ff00ff;
            --tactical-dark: rgba(5, 20, 10, 0.85);
            --border-glow: 0 0 10px rgba(57, 255, 20, 0.3);
            --red-alert: #ff003c;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            color: var(--neon-green);
            font-family: 'Share Tech Mono', monospace;
            overflow: hidden;
            user-select: none;
        }

        /* p5.js Canvas Container */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            width: 100%;
            height: 100%;
        }

        /* CRT Scanline Overlay */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 6px 100%;
            z-index: 10;
            pointer-events: none;
        }

        /* UI Overlay Layout */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
            display: grid;
            grid-template-columns: 40% 60%;
            grid-template-rows: 60px 1fr 250px;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px;
        }

        /* Common Panel Styles */
        .panel {
            background: var(--tactical-dark);
            border: 1px solid var(--neon-green);
            box-shadow: var(--border-glow);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            position: relative;
            backdrop-filter: blur(3px);
        }

        .panel-title {
            background: var(--neon-green);
            color: #000;
            padding: 4px 10px;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: inline-block;
            align-self: flex-start;
        }

        /* Header */
        header {
            grid-column: 1 / 3;
            grid-row: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--neon-green);
            padding-bottom: 10px;
            text-shadow: 0 0 5px var(--neon-green);
        }

        header h1 {
            margin: 0;
            font-size: 24px;
            letter-spacing: 2px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .blink-dot {
            width: 12px;
            height: 12px;
            background-color: var(--neon-green);
            border-radius: 50%;
            animation: blink 1.5s infinite alternate;
        }

        @keyframes blink {
            from { opacity: 0.3; box-shadow: 0 0 2px var(--neon-green); }
            to { opacity: 1; box-shadow: 0 0 12px var(--neon-green); }
        }

        /* Specific Panels */
        #panel-1 {
            grid-column: 1;
            grid-row: 2 / 4;
            background: transparent;
            border-right: 1px dashed rgba(57, 255, 20, 0.4);
            border-left: none;
            border-top: none;
            border-bottom: none;
            box-shadow: none;
            pointer-events: none;
        }

        #panel-2 {
            grid-column: 2;
            grid-row: 2;
            background: transparent;
            border: none;
            box-shadow: none;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding-bottom: 20px;
        }

        .power-readout {
            position: absolute;
            bottom: 10px;
            right: 10px;
            text-align: right;
            font-size: 14px;
        }
        
        .power-readout .highlight {
            color: var(--cyan);
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 8px var(--cyan);
        }

        /* Controls Panel (Panel 3) */
        #panel-3 {
            grid-column: 2;
            grid-row: 3;
            display: flex;
            flex-direction: row;
            gap: 20px;
            padding: 15px;
        }

        .controls-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .controls-right {
            flex: 1.5;
            display: flex;
            flex-direction: column;
        }

        /* Inputs & Buttons */
        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .slider-container label {
            font-size: 12px;
            color: var(--amber);
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 10px;
            background: var(--amber);
            cursor: pointer;
            box-shadow: 0 0 5px var(--amber);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255, 191, 0, 0.3);
            border-radius: 2px;
        }

        .btn {
            background: rgba(0, 20, 0, 0.5);
            color: var(--neon-green);
            border: 1px solid var(--neon-green);
            padding: 10px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: var(--neon-green);
            color: #000;
            box-shadow: 0 0 15px var(--neon-green);
        }

        .btn.btn-danger {
            border-color: var(--red-alert);
            color: var(--red-alert);
        }

        .btn.btn-danger:hover {
            background: var(--red-alert);
            color: #000;
            box-shadow: 0 0 15px var(--red-alert);
        }

        /* Terminal Display */
        #terminal {
            flex: 1;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(57, 255, 20, 0.3);
            padding: 10px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.4;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .log-entry { margin: 0; }
        .log-info { color: var(--neon-green); }
        .log-warn { color: var(--amber); }
        .log-crit { color: var(--red-alert); font-weight: bold; }
        .log-sys { color: var(--cyan); }

        /* Custom Scrollbar for Terminal */
        #terminal::-webkit-scrollbar { width: 5px; }
        #terminal::-webkit-scrollbar-track { background: transparent; }
        #terminal::-webkit-scrollbar-thumb { background: var(--neon-green); }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div class="scanlines"></div>

    <div id="ui-layer">
        <header>
            <h1>V2.0 HARDWARE PIVOT: ANALOG COMPUTATION MATRIX</h1>
            <div class="status-indicator">
                <span id="system-status">SYSTEM NOMINAL</span>
                <div class="blink-dot"></div>
            </div>
        </header>

        <div id="panel-1" class="panel">
            <div class="panel-title">PANEL 1: PIEZO-HYDROPHONE SWARM</div>
            <div style="position: absolute; bottom: 20px; left: 20px; font-size: 12px; color: rgba(57,255,20,0.6);">
                DEFECTIVE COTS SENSORS: <span id="node-count-ui">100</span><br>
                ENVIRONMENT: DEEP OCEAN TRENCH<br>
                STATE: CHAOTIC PULSE
            </div>
        </div>

        <div id="panel-2" class="panel">
            <div class="panel-title" style="position: absolute; top: 0; left: 0;">PANEL 2: MEMRISTOR CROSSBAR ARRAY</div>
            
            <!-- Labels overlay for the p5 canvas elements -->
            <div style="position: absolute; top: 20px; right: 20px; text-align: right; font-size: 12px;">
                <span style="color: var(--amber);">[AMBER]</span> RERAM WEIGHTS<br>
                <span style="color: var(--magenta);">[MAGENTA]</span> TARGET WAVEFORM<br>
                <span style="color: var(--cyan);">[CYAN]</span> PASSIVE OUTPUT
            </div>

            <div class="power-readout">
                ZERO ADC. PASSIVE KIRCHHOFF COMPUTATION.<br>
                POWER DRAW: <span class="highlight">45 nW</span> (NanoWatts)
            </div>
        </div>

        <div id="panel-3" class="panel">
            <div class="panel-title" style="position: absolute; top: -12px; left: -1px;">PANEL 3: HARDWARE REALITY CHECKS (RED TEAM)</div>
            
            <div class="controls-left">
                <div class="slider-container">
                    <label>HYDROPHONE MANUFACTURING VARIANCE [%]</label>
                    <input type="range" id="variance-slider" min="0" max="100" value="100">
                    <div style="display: flex; justify-content: space-between; font-size: 10px; margin-top: 2px;">
                        <span>0% (UNIFORM/FAILS)</span>
                        <span id="variance-val">100% (CHAOS/OPTIMAL)</span>
                    </div>
                </div>

                <button class="btn" id="btn-destroy-adc">DESTROY CPU / ADCS</button>
                <button class="btn btn-danger" id="btn-kinetic">KINETIC STRIKE (60% LOSS)</button>
            </div>

            <div class="controls-right">
                <div id="terminal">
                    <div class="log-entry log-sys">[SYS] INITIALIZING V2.0 PASSIVE ANALOG MATRIX...</div>
                    <div class="log-entry log-sys">[SYS] ZERO-POWER COMPUTATION ESTABLISHED.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- UI Interaction Logic ---
        const terminal = document.getElementById('terminal');
        const varianceSlider = document.getElementById('variance-slider');
        const varianceVal = document.getElementById('variance-val');
        
        function logMsg(msg, level="info") {
            const div = document.createElement('div');
            div.className = `log-entry log-${level}`;
            const time = new Date().toISOString().substring(11, 23);
            div.textContent = `[${time}] ${msg}`;
            terminal.appendChild(div);
            terminal.scrollTop = terminal.scrollHeight;
            
            // Limit log history
            if (terminal.childElementCount > 30) {
                terminal.removeChild(terminal.firstChild);
            }
        }

        varianceSlider.addEventListener('input', (e) => {
            const val = e.target.value;
            if(val == 100) {
                varianceVal.textContent = "100% (CHAOS/OPTIMAL)";
            } else if (val == 0) {
                varianceVal.textContent = "0% (UNIFORM/FAILS)";
            } else {
                varianceVal.textContent = `${val}%`;
            }
            // Update p5 variable
            if(window.p5System) window.p5System.setVariance(val / 100);
        });

        document.getElementById('btn-destroy-adc').addEventListener('click', () => {
            logMsg("ATTEMPTING TO DISABLE DIGITAL COMPONENTS...", "warn");
            setTimeout(() => {
                logMsg("NO DIGITAL COMPONENTS FOUND. PURE ANALOG NETWORK OPERATIONAL.", "info");
            }, 400);
        });

        document.getElementById('btn-kinetic').addEventListener('click', () => {
            logMsg("INCOMING KINETIC STRIKE DETECTED!", "crit");
            if(window.p5System) window.p5System.triggerKineticStrike();
            
            setTimeout(() => {
                logMsg("60% NODES OFFLINE.", "crit");
            }, 200);
            
            setTimeout(() => {
                logMsg("KIRCHHOFF CURRENT REDISTRIBUTION ACTIVE. GRACEFUL DEGRADATION WITHOUT CLOUD COMPUTE.", "sys");
            }, 800);
        });


        // --- P5.JS Simulation Backend ---
        const sketch = (p) => {
            
            // Colors
            const C_BG = p.color(3, 10, 5);
            const C_GREEN = p.color(57, 255, 20);
            const C_GREEN_DIM = p.color(20, 100, 10);
            const C_RED = p.color(255, 0, 60);
            const C_AMBER = p.color(255, 191, 0);
            const C_CYAN = p.color(0, 255, 255);
            const C_MAGENTA = p.color(255, 0, 255);
            
            // State
            let nodes = [];
            const NUM_NODES = 100;
            let variance = 1.0; 
            let networkHealth = 1.0; 
            let targetHealth = 1.0;
            
            // Geometry mappings
            let leftZone, rightZone;
            let crossbar = {
                cols: 16,
                rows: 8,
                startX: 0,
                startY: 0,
                spacing: 0,
                weights: []
            };

            // Oscilloscope history
            let historyTarget = [];
            let historyOutput = [];
            const MAX_HISTORY = 300;
            let timeStep = 0;

            // Sonar Ping
            let sonar = {
                active: true,
                x: 0,
                speed: 3
            };

            p.setup = () => {
                let canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('canvas-container');
                p.frameRate(60);
                
                initGeometry();
                initNodes();
                initCrossbar();

                // Expose to HTML UI
                window.p5System = {
                    setVariance: (v) => { variance = v; },
                    triggerKineticStrike: () => {
                        let deadCount = 0;
                        let targetDead = Math.floor(NUM_NODES * 0.6);
                        
                        // Shuffle nodes to kill random ones
                        let shuffled = [...nodes].sort(() => 0.5 - Math.random());
                        for(let i=0; i < shuffled.length; i++) {
                            if (shuffled[i].isAlive && deadCount < targetDead) {
                                shuffled[i].isAlive = false;
                                deadCount++;
                            }
                        }
                        networkHealth = 0.2; // Drop accuracy immediately
                        document.getElementById('node-count-ui').textContent = (NUM_NODES - targetDead);
                    }
                };
            };

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                initGeometry();
                initCrossbar(); // Recalculate positions
            };

            function initGeometry() {
                // Map regions to the CSS Grid layout
                leftZone = {
                    x: 20,
                    y: 80,
                    w: p.width * 0.4 - 40,
                    h: p.height - 100
                };
                rightZone = {
                    x: p.width * 0.4 + 20,
                    y: 80,
                    w: p.width * 0.6 - 40,
                    h: p.height - 350 // Leave room for UI panel
                };
            }

            function initNodes() {
                nodes = [];
                for(let i=0; i < NUM_NODES; i++) {
                    nodes.push({
                        x: p.random(leftZone.x, leftZone.x + leftZone.w - 50),
                        y: p.random(leftZone.y + 20, leftZone.y + leftZone.h - 20),
                        basePhase: p.random(p.TWO_PI),
                        freq: p.random(0.02, 0.1),
                        isAlive: true,
                        pulse: 0,
                        wireTargetCol: i % 16 // Connect to one of the 16 crossbar columns
                    });
                }
            }

            function initCrossbar() {
                crossbar.spacing = Math.min((rightZone.w - 100) / crossbar.cols, (rightZone.h * 0.5) / crossbar.rows);
                crossbar.startX = rightZone.x + (rightZone.w - (crossbar.cols * crossbar.spacing)) / 2;
                crossbar.startY = rightZone.y + 20;

                // Init random fixed weights for the "memristors"
                if (crossbar.weights.length === 0) {
                    for(let i=0; i<crossbar.cols; i++) {
                        crossbar.weights[i] = [];
                        for(let j=0; j<crossbar.rows; j++) {
                            crossbar.weights[i][j] = p.random(0.1, 1.0);
                        }
                    }
                }
            }

            p.draw = () => {
                p.clear(); // Transparent background, CSS handles base color
                
                // Slowly recover network health (Graceful Degradation)
                if (networkHealth < targetHealth) {
                    networkHealth += 0.005; 
                }

                updateSonar();
                drawOceanBackground();
                drawWires(); // Draw wires before nodes and crossbar
                drawSwarm();
                drawCrossbarArray();
                drawOscilloscope();
                
                timeStep += 0.05;
            };

            function updateSonar() {
                sonar.x += sonar.speed;
                if (sonar.x > leftZone.x + leftZone.w) {
                    sonar.x = leftZone.x - 100; // Reset
                }
            }

            function drawOceanBackground() {
                // Optional subtle particle effects or gradient inside leftZone
                p.noStroke();
                p.fill(0, 10, 5, 100);
                p.rect(leftZone.x, leftZone.y, leftZone.w, leftZone.h);
            }

            function drawSwarm() {
                p.strokeWeight(1);
                
                // Draw Sonar line
                p.stroke(0, 150, 150, 100);
                p.line(sonar.x, leftZone.y, sonar.x, leftZone.y + leftZone.h);
                
                for(let n of nodes) {
                    let d = p.abs(n.x - sonar.x);
                    
                    // Excitation from Sonar
                    if (d < 50 && n.isAlive) {
                        n.pulse = p.lerp(n.pulse, 1.0, 0.2);
                    } else {
                        n.pulse = p.lerp(n.pulse, 0.0, 0.05);
                    }

                    // Chaos logic dependent on variance slider
                    // If variance is 0, they sync up (bad for stochastic resonance).
                    // If variance is 1, they have chaotic independent phases (good).
                    let currentPhase = p.lerp(timeStep, timeStep + n.basePhase, variance);
                    let flicker = (p.sin(currentPhase * n.freq * 10) * 0.5 + 0.5) * n.pulse;
                    
                    if (!n.isAlive) {
                        p.stroke(C_RED);
                        p.fill(100, 0, 0, 150);
                    } else {
                        // Color shifts based on variance and pulse
                        let c = p.lerpColor(C_GREEN_DIM, C_GREEN, flicker + 0.2);
                        p.stroke(c);
                        p.fill(p.red(c), p.green(c), p.blue(c), 100);
                    }

                    p.circle(n.x, n.y, n.isAlive ? 4 + flicker * 6 : 3);
                    
                    // Node subtle movement
                    if (n.isAlive) {
                        n.y += p.sin(timeStep + n.basePhase) * 0.2;
                    }
                }
            }

            function drawWires() {
                p.noFill();
                // Draw bezier curves connecting left swarm area to right crossbar columns
                // Group nodes by their target column to find an average starting point
                let colStarts = new Array(crossbar.cols).fill({x:0, y:0, count:0});
                
                for(let n of nodes) {
                    if (n.isAlive) {
                        let c = n.wireTargetCol;
                        colStarts[c] = {
                            x: colStarts[c].x + n.x,
                            y: colStarts[c].y + n.y,
                            count: colStarts[c].count + 1
                        };
                    }
                }

                p.strokeWeight(1);
                for(let i=0; i<crossbar.cols; i++) {
                    if (colStarts[i].count > 0) {
                        let avgX = colStarts[i].x / colStarts[i].count;
                        let avgY = colStarts[i].y / colStarts[i].count;
                        
                        let targetX = crossbar.startX + i * crossbar.spacing;
                        let targetY = crossbar.startY;

                        // Wire glow depends on network health
                        p.stroke(57, 255, 20, 20 * networkHealth);
                        
                        p.beginShape();
                        p.vertex(avgX, avgY);
                        p.bezierVertex(
                            avgX + 150, avgY, 
                            targetX, targetY - 100, 
                            targetX, targetY
                        );
                        p.endShape();
                    }
                }
            }

            function drawCrossbarArray() {
                let w = crossbar.cols * crossbar.spacing;
                let h = crossbar.rows * crossbar.spacing;
                
                // Draw Grid Lines
                p.strokeWeight(2);
                for(let i=0; i<crossbar.cols; i++) {
                    let x = crossbar.startX + i * crossbar.spacing;
                    // Vertical (Input)
                    p.stroke(20, 100, 50, 150);
                    p.line(x, crossbar.startY, x, crossbar.startY + h - crossbar.spacing);
                }

                for(let j=0; j<crossbar.rows; j++) {
                    let y = crossbar.startY + j * crossbar.spacing;
                    // Horizontal (Output)
                    p.stroke(20, 50, 100, 150);
                    p.line(crossbar.startX, y, crossbar.startX + w + 20, y);
                }

                // Draw Memristors at Intersections
                p.noStroke();
                for(let i=0; i<crossbar.cols; i++) {
                    for(let j=0; j<crossbar.rows; j++) {
                        let x = crossbar.startX + i * crossbar.spacing;
                        let y = crossbar.startY + j * crossbar.spacing;
                        
                        // Fluctuate weights slightly for analog feel
                        let dynamicWeight = crossbar.weights[i][j] * (0.8 + 0.2 * p.sin(timeStep + i*j));
                        
                        // Amber glow
                        let alpha = 50 + 200 * dynamicWeight * networkHealth;
                        p.fill(255, 191, 0, alpha);
                        
                        // Size pulses slightly
                        let r = 4 + 2 * dynamicWeight;
                        p.circle(x, y, r);
                        
                        // Inner hot core
                        p.fill(255, 255, 200, alpha);
                        p.circle(x, y, r/2);
                    }
                }
            }

            function drawOscilloscope() {
                let scopeX = rightZone.x;
                let scopeY = crossbar.startY + (crossbar.rows * crossbar.spacing) + 40;
                let scopeW = rightZone.w;
                let scopeH = rightZone.h - (scopeY - rightZone.y);

                // Scope background grid
                p.stroke(0, 50, 0, 100);
                p.strokeWeight(1);
                for(let i=0; i<10; i++) {
                    p.line(scopeX, scopeY + (i/10)*scopeH, scopeX + scopeW, scopeY + (i/10)*scopeH);
                    p.line(scopeX + (i/10)*scopeW, scopeY, scopeX + (i/10)*scopeW, scopeY + scopeH);
                }

                // Mathematics for Target vs Output Signal
                // Target is a complex waveform
                let targetVal = p.sin(timeStep*2) * 0.5 + p.cos(timeStep*0.5) * 0.3;
                
                // Output relies on chaos (variance) and health.
                // High variance = stochastically computes properly. Low variance = fails.
                let signalQuality = p.map(variance, 0, 1, 0.1, 1.0) * networkHealth;
                
                // Add some noise that increases when quality is low
                let analogNoise = p.random(-0.1, 0.1) * (1.0 - signalQuality);
                
                // When variance is 0, signal flats out or becomes pure noise
                let outputVal = targetVal * signalQuality + analogNoise;

                historyTarget.push(targetVal);
                historyOutput.push(outputVal);

                if (historyTarget.length > MAX_HISTORY) {
                    historyTarget.shift();
                    historyOutput.shift();
                }

                // Plot Target Wave (Magenta)
                p.noFill();
                p.stroke(C_MAGENTA);
                p.strokeWeight(2);
                p.beginShape();
                for(let i=0; i<historyTarget.length; i++) {
                    let x = scopeX + p.map(i, 0, MAX_HISTORY, 0, scopeW);
                    let y = scopeY + scopeH/2 - historyTarget[i] * (scopeH/2.5);
                    p.vertex(x, y);
                }
                p.endShape();

                // Plot Output Wave (Cyan)
                p.stroke(C_CYAN);
                p.strokeWeight(2);
                p.beginShape();
                for(let i=0; i<historyOutput.length; i++) {
                    let x = scopeX + p.map(i, 0, MAX_HISTORY, 0, scopeW);
                    let y = scopeY + scopeH/2 - historyOutput[i] * (scopeH/2.5);
                    p.vertex(x, y);
                }
                p.endShape();
                
                // Draw current tracking point
                if (historyOutput.length > 0) {
                    let lastX = scopeX + scopeW;
                    let lastY = scopeY + scopeH/2 - historyOutput[historyOutput.length-1] * (scopeH/2.5);
                    p.fill(C_CYAN);
                    p.noStroke();
                    p.circle(lastX, lastY, 6);
                }
            }
        };

        // Initialize p5
        new p5(sketch);

    </script>
</body>
</html>
